```C#
namespace _20250916_Interface
{
   // interface
   // 행동규약
   // 1. 인터페이스는 메소드, 이벤트, 인덱서, 프로퍼티만 가질 수 있습니다.
   // 2. 접근제어자를 사용할 수 없고, 모든 것이 public으로 선언됩니다.
   // 3. 구현부가 없습니다.
   // 4. interface를 추가한 클래스는 interface에 선언된 메소드를 구현할 책임을 갖습니다.
   // 5. interface는 다중으로 추가할 수 있습니다.


   interface Move
   {
      void Start();
      void Stop();
      void Acceleration();

   }

   class Car : Move
   {
      private string _modelName;
      private float _maxSpeed;

      public Car(string modelName, float maxSpeed)
      {
         _modelName = modelName;
         _maxSpeed = maxSpeed;
      }

      public void Start()
      {
         Console.WriteLine($"{_modelName}이 출발합니다.");
      }

      public void Stop()
      {
         Console.WriteLine($"{_modelName}이 정지합니다.");
      }

      public void Acceleration()
      {
         Console.WriteLine($"{_modelName}이 가속을 합니다.");
      }

   }


   class Ship : Move
   {
      private string _name;
      private float _maxSpeed;

      public Ship(string name, float maxSpeed)
      {
         _name = name;
         _maxSpeed = maxSpeed;
      }

      public void Start()
      {
         Console.WriteLine($"{_name}이 출항합니다.");
      }

      public void Stop()
      {
         Console.WriteLine($"{_name}이 입항합니다.");
      }

      public void Acceleration()
      {
         Console.WriteLine($"{_name}이 가속합니다.");
      }
   }

   internal class Program
   {
      static void Main(string[] args)
      {
         Car car = new Car("GV80", 280.0f);
         Ship ship = new Ship("쾌속선", 50.0f);

         Move move = car;

         move.Start();
         move.Stop();
         move.Acceleration();

         

         move = ship;

         move.Start();
         move.Stop();
         move.Acceleration();

         Console.WriteLine();

         Move[] moveArray = new Move[] { car, ship };

         foreach(var obj in moveArray)
         {
            obj.Start();
            obj.Acceleration();
            obj.Stop();

            Console.WriteLine();
         }


      }
   }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _20250916_MultiInterface
{
   // 멀티 인터페이스


   public abstract class Run  // 추상 클래스
   {
      public abstract void Walk(); // 추상 메소드
   }

   public class Human : Run
   {
      public override void Walk()
      {
         Console.WriteLine($"사람이 걷는다.");
      }
   }


   class A
   {
      private int _value;

      public int Value { get { return _value; } set { _value = value; } }
   }

   interface IRunnable
   {

      int Speed { set; get; } // 자동구현 프로퍼티
      void Run();
   }

   interface IFlyable
   {
      void Fly();
   }

   class FlyingCar : IRunnable, IFlyable
   {
      public int Speed { set; get; }

      public void Run()
      {
         Console.WriteLine("Run! Run!");
      }

      public void Fly()
      {
         Console.WriteLine("Fly! Fly!");
      }
   }

   internal class Program
   {
      static void Main(string[] args)
      {
         FlyingCar car = new FlyingCar();

         car.Run();
         car.Fly();

         IRunnable runnable = car;
         runnable.Run();


         IFlyable flyable = car;
         flyable.Fly();


            
         Human human = new Human();

         human.Walk();


      }
   }
}


//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

using System;
using System.Collections.Generic;
using System.ComponentModel.Design.Serialization;
using System.Transactions;


namespace _202509161322_Indexer
{
   // indexer
   // indexer(인덱서)는 C#에서 클래스나 구조체 타입의 객체를 배열처럼 접근할 수 있게 해주는
   // 일종의 property입니다.
   // 인덱서를 사용하면 객체 내부의 Data collection을 배열 구문을 사용해서 접근할 수 있게 해주는 기능...
   // 사용성 좋아지고 코드의 가독성이 좋아집니다.
   class NumArray
   {
      private List<int> datas = new List<int>(10);

      public int Length
      {
         get { return datas.Count; }

      }
      public int this[int index]
      {
         get { return datas[index]; }
         set
         {
            if (datas.Count <= 0)
            {
               datas.Add(value);
            }
            else if (datas.Count <= index)
            {
               datas.Add(value);
            }
            else
            {
               datas[index] = value;
            }

         }
      }
   }

   class NumArray2
   {
      private int[] datas = new int[10]; // Container

      public int Length
      {
         get { return datas.Length; }

      }
      public int this[int index] // 인덱서
      {
         get { return datas[index]; }
         set
         {
            if (datas.Length <= index)
            {
               int[] datas2 = new int[index + 1];

               for (int i = 0; i < datas.Length; i++)
               {
                  datas2[i] = datas[i];
               }
               datas = datas2;

               datas[index] = value;
            }
            else
            {
               datas[index] = value;
            }

         }
      }
   }


   class NumArray3
   {
      private int[] datas = new int[10];

      public int this[int index] // index
      {
         get { return datas[index]; }
         set { datas[index] = value; }
      }

      public void SetArray(int index, int value)
      {
         datas[index] = value;
      }

      public int GetArray(int index)
      {
         return datas[index];
      }

      public int GetSize()
      {
         return datas.Length;
      }
   }


   class Program
   {
      static void Main(string[] args)
      {
         NumArray3 numarray3 = new NumArray3();

         /*
         numarray3.SetArray(0, 10);

         numarray3.SetArray(5, 200);

         for(int i =0; i < numarray3.GetSize(); i++)
         {
            Console.WriteLine($"numarray3[{i}] = {numarray3.GetArray(i)}");
         }
         */


         numarray3[0] = 10;
         numarray3[5] = 200;

         //numarray3[11] = 400;

         for (int i = 0; i < numarray3.GetSize(); i++)
         {
            Console.WriteLine($"numarray3[{i}] = {numarray3[i]}");
         }


         /*

         NumArray numArray = new NumArray();

         numArray[0] = 1; // 인덱서를 사용해서 객체를 배열 형식으로 접근하고 있음.
         numArray[1] = 2;
         numArray[2] = 3;
         numArray[3] = 4;


         for (int i = 0; i < numArray.Length; i++)
         {
            numArray[i] = i;
         }

         for (int i = 0; i < numArray.Length; i++)
         {
            Console.WriteLine($"numArray[{i}] = {numArray[i]}");
         }


         NumArray2 numArray2 = new NumArray2();

         for (int i = 0; i < numArray2.Length; i++)
         {
            numArray2[i] = i;
         }


         for (int i = 0; i < numArray2.Length; i++)
         {
            Console.WriteLine($"numArray2[{i}] = {numArray2[i]}");
         }

         numArray2[11] = 2;

         Console.WriteLine();

         for (int i = 0; i < numArray2.Length; i++)
         {
            Console.WriteLine($"numArray2[{i}] = {numArray2[i]}");
         }
         */


      }
   }
}



//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _202509161323_Indexer
{
   public enum GameGenre
   {
      Rpg,
      Action,
      Adventure,
      Fps
   }

   public struct GameTitle
   {
      public string _name;    // 게임명
      public string _releaseDate; // 출시 년월일
      public GameGenre _type; // 게임 종류

      public GameTitle(string name, string releaseDate, GameGenre type)
      {
         _name = name;
         _releaseDate = releaseDate;
         _type = type;
      }

   }


   // 인덱서를 사용하지 않음.
   public class GameTitleData
   {
      private List<GameTitle> datas = new List<GameTitle>();

      public void addGameTitle(GameTitle data)
      {
         datas.Add(data);
      }

      public GameTitle getGameTitle(int index)
      {
         return datas[index];
      }

      public GameTitle findGameTile(string gameName)
      {
         for (int i = 0; i < datas.Count; i++)
         {
            if (datas[i]._name == gameName)
            {
               return datas[i];
            }
         }

         return new GameTitle("없음", "0000", GameGenre.Action);
      }
   }

   public class GameTitleDataIndexer // 인덱서를 사용
   {
      private List<GameTitle> datas = new List<GameTitle>(10);


      // indexer
      public GameTitle this[int index]
      {
         get { return datas[index]; }
         set
         {
            if (datas.Count == 0)
            {
               datas.Add(value);
            }
            else if (datas.Count <= index)
            {
               datas.Add(value);
            }
            else
            {
               datas[index] = value;
            }

         }
      }

      public GameTitle FindGameTile(string gameName)
      {
         for (int i = 0; i < datas.Count; i++)
         {
            if (datas[i]._name == gameName)
            {
               return datas[i];
            }
         }

         return new GameTitle("없음", "0000", GameGenre.Action);
      }
   }

   internal class Program
   {
      static void Main(string[] args)
      {
         GameTitleData gameData = new GameTitleData();
         gameData.addGameTitle(new GameTitle("리니지", "19951110", GameGenre.Rpg));
         gameData.addGameTitle(new GameTitle("리니지1", "19951110", GameGenre.Rpg));
         gameData.addGameTitle(new GameTitle("리니지2", "19951110", GameGenre.Rpg));
         gameData.addGameTitle(new GameTitle("리니지3", "19951110", GameGenre.Rpg));


         GameTitle data = gameData.getGameTitle(0);

         Console.WriteLine($"제목:{data._name}, 출시년월일: {data._releaseDate}, 게임장르:{data._type.ToString()}");


         GameTitleDataIndexer gameData2 = new GameTitleDataIndexer();

         gameData2[0] = new GameTitle("리니지", "19951110", GameGenre.Rpg);
         gameData2[1] = new GameTitle("리니지1", "19951110", GameGenre.Rpg);
         gameData2[2] = new GameTitle("리니지2", "19951110", GameGenre.Rpg);
         gameData2[3] = new GameTitle("리니지3", "19951110", GameGenre.Rpg);


         Console.WriteLine($"제목:{gameData2[0]._name}, 출시년월일: {gameData2[0]._releaseDate}, 게임장르:{gameData2[0]._type.ToString()}");

         gameData2[2] = new GameTitle("리니지2-1", "19951110", GameGenre.Rpg);
         Console.WriteLine($"제목:{gameData2[2]._name}, 출시년월일: {gameData2[2]._releaseDate}, 게임장르:{gameData2[2]._type.ToString()}");

      }
   }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

using System.Net.Cache;

namespace _202509161329_Tuple
{
   internal class Program
   {
      public struct Data
      {
         public string item1;
         public int item2;

         public Data(string item1, int item2)
         {
            this.item1 = item1;
            this.item2 = item2;
         }

      }

      static void Main(string[] args)
      {
         // Tupple: 간단한 데이타 구조로 여러 데이타 요소를 그룹화할 때 사용.

         var ccc = 100;  // 타입유추


         Data db = new Data("고릴라", 100);

         // 명명되지 않은 튜플
         var a = ("고릴라", 100);

         Console.WriteLine($"{a.Item1}, {a.Item2}");

         // 명명된 튜플
         var b = (Kind: "Tiger", Age: 17);

         Console.WriteLine($"{b.Kind}, {b.Age}");

         // 분해
         var (name, age) = a;
         Console.WriteLine($"{name}, {age}");

         // 명명된 튜플 = 명명되지 않은 튜플
         b = a;
         Console.WriteLine($"{b.Kind}, {b.Age}");

         var c = ( 1, 2, 3, 4, 5 );

         Console.WriteLine($"{c.Item1}, {c.Item2}, {c.Item3}, {c.Item4}, {c.Item5}");

         Tuple<int, int, int, int, int> aa = new Tuple<int, int, int, int, int>(1, 2, 3, 4, 5);



      }
   }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _202509171228_Composition
{

   // 포함
   // Composition: (포함) 강한 결합, 생명주기를 같이함
   // Agreggation: (참조) 약한 결합, 생명주기를 같이 하지 않음..


   class Heart
   {
      private float _purse;
      public Heart()
      {
         Console.WriteLine("Heart 생성자");
      }

      public Heart(float purse)
      {
         _purse = purse;
      }

      public void Check()
      {
         Console.WriteLine($"심장이 정상 작동중입니다.");
      }
   }

   class SmartPhone
   {
      private string _blendName;

      public SmartPhone(string blendName)
      {
         _blendName = blendName;
         Console.WriteLine($"{_blendName} SmartPhone 생성자");
      }

      public void Display()
      {
         Console.WriteLine($"{_blendName} 폰이 정상 작동 중입니다.");
      }
   }

   class Human
   {
      const int MAX = 100; // const는 변수를 만듦과 동시에 초기화 가 되어야 합니다.
      public readonly Heart _heart;// readonly 실행중에 초기화가 될 수 있습니다.
                             // 초기화가 된 이후 값을 변경할 수 없습니다.
      private SmartPhone _smartPhone;  // Agreggation

      public Human(SmartPhone smartPhone)
      {
         Console.WriteLine("Human 생성자");
         _heart = new Heart(70.0f);
         _smartPhone = smartPhone;
      }

      public Human(SmartPhone smartPhone, float purse)
      {
         _heart = new Heart(purse);
         _smartPhone = smartPhone;
      }

      public void CheckHeart()
      {
         _heart.Check();
      }

      public void UsePhone()
      {
         _smartPhone.Display();
      }

      public void ChangePhone(SmartPhone phone)
      {
         _smartPhone = phone;
      }
   }

   class Program
   {
      static void Main(string[] args)
      {
         SmartPhone samsungPhone = new SmartPhone("SamSung");
         SmartPhone iPhone = new SmartPhone("Apple");

         Human human = new Human(samsungPhone, 70.0f);

         // human._heart = new Heart();

         human.CheckHeart();
         human.UsePhone();

         // 전화기를 바꿈.
         human.ChangePhone(iPhone);

         human.UsePhone();




      }
   }
}


```
