```C#
using System.Net.Http.Headers;
using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;

namespace _20250925_Nested_Class
{
    // 중첩클래스
    // 클래스 안에 클래스를 정의하는것을 중첩클래스라고 한다
    // 클래스 내부에서만 사용되기 때문에 코드를 더 쉽게 파악할 수 있다. 유지관리가 쉽다.
    // 클래스 구조가 단순해진다.
    // 클래스 외부에 공개하굎지 않은 형식을 만들고자 할때

    class Configuration
    {
        List<ItemValue> listConfig = new List<ItemValue>();

        public void SetConfig(string item, string value)
        {
            ItemValue iv = new ItemValue();
            iv.SetValue(this,item,value);
        }

        public string GetConfig(string item)
        {
            foreach (ItemValue iv in listConfig)
            {
                if (iv.GetItem() == item)
                    return iv.GetValue();
            }

            return "";
        }

        private class ItemValue // 중첩클래스
        {
            private string item;
            private string value;

            public void SetValue(Configuration config, string item, string value)
            {
                this.item = item;
                this.value = value;

                bool found = false;
                for (int i = 0; i < config.listConfig.Count; i++)
                {
                    if (config.listConfig[i].item == item)
                    {
                        config.listConfig[i] = this;
                        found = true;
                        break;
                    }
                }

                if (found == false)
                    config.listConfig.Add(this);
            }

            public string GetItem()
            { return item; }
            public string GetValue()
            { return value; }
        }
    }
    internal class MainApp
    {
        static void Main(string[] args)
        {
            Configuration config = new Configuration();
            config.SetConfig("Version", "V 5.0");
            config.SetConfig("Size", "655,324 KB");

            Console.WriteLine(config.GetConfig("Version"));
            Console.WriteLine(config.GetConfig("Size"));

            config.SetConfig("Version", "V 5.0.1");
            Console.WriteLine(config.GetConfig("Version"));
        }
    }
}


// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

using System;

namespace _202509241356_Nested_Class2
{
   public class School
   {
      public void PrintSchool()
      {
         Console.WriteLine("PrintSchool() Method 호출");
      }

      public class Teacher // 중첩 클래스
      {
         public void PrintTeacher()
         {
            School school = new School();
            school.PrintSchool();
            Console.WriteLine("PrintTeacher() Method 호출");
         }
      }
   }

   class Program
   {
      static void Main(string[] args)
      {
         School.Teacher teacher = new School.Teacher();

         teacher.PrintTeacher();

      }
   }
}

// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
using System;

namespace _202509251158_AnonymousType
{
   class Test
   {
      int value;
      int value2;
   }

   // Anonymous Type(익명타입)
   // new {...}를 사용해야합니다.
   // 익명 타입은 명시적으로 클래스를 정의하지않고 임시로 타이을 생성할 수 있는 기능
   // 컴파일러가 내부적으로 클래스르 생성하므로, 일반적으로 참조 타입과 동일하게 동작합니다.
   // 변수를 할당시 var타입을 사용
   // 읽기 전용






   class Program
   {
      public static (bool isSuccess, float prob) ProbabilityCalculator(float prob)
      {
         bool isSuccess = true;
         float value = 2.3f * prob;

         return (isSuccess, value);
      }

      static void Main(string[] args)
      {
         var a = new { Name = "Monster", Age = 100 };
         //a.Name = "monster2"; // 읽기만 가능

         Console.WriteLine("Name:{0}, Age: {1}", a.Name, a.Age);

         var b = new { Subject = "Mathmetics", Scores = new int[] { 90, 80, 70, 60 } };

         Console.WriteLine("Subject:{0}, Scores: ", b.Subject);
         foreach (var score in b.Scores)
         {
            Console.Write("{0} ", score);
         }

         Console.WriteLine();

         var data = ProbabilityCalculator(10.0f);


         Console.WriteLine($"data = {data}");

      }
   }
}

// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
using System;

namespace _20250925_GenericProgramming
{

   // generic programming(일반화 프로그래밍)

   class Test
   {
      int _value;
      int _value2;

      public Test(int value, int value2)
      {
         _value = value;
         _value2 = value2;
      }

      public override string ToString()
      {
         return $"_value = {_value}, _value2 = {_value2}";
      }
   }


   class Program
   {
      /*
      static void Swap(ref int a, ref int b) 
      {
         int temp = 0;
         temp = a;
         a = b;
         b = temp;
      }

      static void Swap(ref float a, ref float b)
      {
         float temp = 0.0f;
         temp = a;
         a = b;
         b = temp;
      }

      static void Swap(ref double a, ref double b)
      {
         double temp = 0.0f;
         temp = a;
         a = b;
         b = temp;
      }

      static void Swap(ref string a, ref string b)
      {
         string temp = "";
         temp = a;
         a = b;
         b = temp;
      }
      */

      static void Swap<T>(ref T a, ref T b) // 일반화 메소드
      {
         T temp;
         temp = a;
         a = b;
         b = temp;
      }



      static void Main(string[] args)
      {
         int a = 20;
         int b = 30;

         float c = 2.4f;
         float d = 3.4f;

         double e = 10.3d;
         double f = 20.4d;

         string str = "monster";
         string str2 = " is World!!";

         Console.WriteLine($"before a = {a} , b = {b}");
         Swap(ref a, ref b);
         Console.WriteLine($"after a = {a} , b = {b}");
         Console.WriteLine();

         Console.WriteLine($"before a = {c} , b = {d}");
         Swap(ref c, ref d);
         Console.WriteLine($"after a = {c} , b = {d}");
         Console.WriteLine();

         Console.WriteLine($"before a = {e} , b = {f}");
         Swap(ref e, ref f);
         Console.WriteLine($"after a = {e} , b = {f}");
         Console.WriteLine();

         Console.WriteLine($"before a = {str} , b = {str2}");
         Swap(ref str, ref str2);
         Console.WriteLine($"after a = {str} , b = {str2}");






      }
   }
}

// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


namespace _20250925_GenericMethod_Exer
{
    internal class Program
    {
        static void PrintAll<T>(T[] item)
        {
            foreach(T i in item)
            {
                Console.Write(i);
            }
            Console.WriteLine();

            //혹은
            for(int i = 0; i < item.Length; i++)
            {
                Console.WriteLine($"{item[i]}");
            }
        }


        static void Main()
        {       


            int[] numbers = { 1, 2, 3, 4, 5 };
            float[] fnumbers = { 3.4f, 7.4f, 8.9f, 10.8f, 12.7f, 13.8f };
            string[] fruits = { "Apple", "Banana", "Cherry" };

            Console.WriteLine("=== Numbers ===");
            PrintAll(numbers);

            Console.WriteLine("==== float ====");
            PrintAll(fnumbers);

            Console.WriteLine("=== Fruits ===");
            PrintAll(fruits);
        }
    }
}

// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _20250925_GenericProgramming
{
    class Test
    {
        private int _num1;
        private int _num2;

        public Test(int num1, int num2)
        {
            _num1 = num1;
            _num2 = num2;
        }

        public override string ToString()
        {
            return $"_num1 = {_num1}, num2 = {_num2};";
        }
        
    }

    class ArrayStack<T>
    {
        private int _index = 0 ;
        private int _size;
        private T[] _array;

        public int Size { get => _size; }

        public ArrayStack(int size)
        {
            _index = 0;
            _size = size;
            _array = new T[size];
        }

        public void Push(T data)  // 스텍 저장
        {
            if(_index >= _size)
            {
                return;
            }
            
            _array[_index++] = data;

        }

        public T Pop() // 스택 가져올때
        {
            if(_index > 0)
            {
                return _array[--_index];
            }
            else
            {
                return default(T);
            }
        }


        public T Top()    // 스택 맨위 확인
        {
            if(_index > 0)
            {
                return _array[_index - 1];
            }
            else
            {
                return default(T);
            }
        }
    }

    /*
    class ArrayStackInt
    {
        private int _index = 0;
        private int _size;
        private int[] _array;

        public int Soze { get => _size; }

        public ArrayStackInt(int size)
        {
            _index = 0;
            _size = size;
            _array = new int[size];
        }

        public void Push(int data)  
        {
            if (_index >= _size)
            {
                return;
            }

            _array[_index++] = data;

        }

        public int Pop() 
        {
            if (_index > 0)
            {
                return _array[--_index];
            }
            else
            {
                return -1;
            }
        }


        public int Top()    
        {
            if (_index > 0)
            {
                return _array[_index - 1];
            }
            else
            {
                return -1;
            }
        }
    }
    */


    class Program
    {
        static void Main(string[] args)
        {
            ArrayStack<float> fstack = new ArrayStack<float>(10);
            
            
            fstack.Push(1.2f);
            fstack.Push(2.2f);
            fstack.Push(3.2f);

            Console.WriteLine($"{fstack.Pop()}");
            Console.WriteLine($"{fstack.Pop()}");
            Console.WriteLine($"{fstack.Pop()}");

            Console.WriteLine();

            ArrayStack<int> Istack = new ArrayStack<int>(10);

            Istack.Push(1);
            Istack.Push(2);
            Istack.Push(3);

            Console.WriteLine($"{Istack.Pop()}");
            Console.WriteLine($"{Istack.Pop()}");
            Console.WriteLine($"{Istack.Pop()}");

            Console.WriteLine();

            ArrayStack<Test> testStack = new ArrayStack<Test>(10);

            for(int i = 0; i < testStack.Size; i++)
            {
                testStack.Push(new Test(i, i * 2));
            }

            for(int i = 0; i < testStack.Size; i++)
            {
                Console.WriteLine($"{testStack.Pop()}");
            }
        }
    }
}

```
