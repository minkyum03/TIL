```C#
namespace _20251001_AnonymousMethod
{
    //무명함수
    
    delegate int Compare(int a, int b);

    class MainApp
    {
        // 정렬
        // 오름차순  /  내림차순

        static void BubbleSort(int[] DataSet, Compare Compare)
        {
            int i = 0;
            int j = 0;
            int temp = 0;
            for (i = 0; i < DataSet.Length - 1; i++)
            {
                for(j = 0;  j < DataSet.Length - (i + 1); j++)
                {
                    if (Compare(DataSet[j], DataSet[j + 1]) > 0)
                    {
                        temp = DataSet[j + 1];
                        DataSet[j + 1] = DataSet[j];
                        DataSet[j] = temp;
                    }
                }
            }
        }

        static void Main(string[] args)
        {
            int[] array = { 3, 7, 4, 2, 10 };

            Console.WriteLine("Sorting ascending...");
            BubbleSort(array, delegate (int a, int b)
            {
                if (a > b) return 1;
                else if (a == b) return 0;
                else return -1;
            });

            for(int i = 0; i < array.Length; i++)
                Console.WriteLine($"{array[i]}");

            int[] array2 = { 7, 2, 8, 10, 11 };
            Console.WriteLine("\nSorting descending");
            BubbleSort(array2, delegate (int a, int b)
            {
                if (a < b) return 1;
                else if (a == b) { return 0; }
                else return -1;
            });

            for (int i = 0; i < array2.Length; i++)
            {
                Console.WriteLine($"{array2[i]}");
            }
            Console.WriteLine();
        }
    }
}

// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _202509301520_AnonymousMethod
{
    // 무명 함수
    struct Fruit
    {
        public string Name;
        public int Count;
        public float brix;
    }

    delegate int Compare<T>(T a, T b);

    class MainApp
    {
        // 정렬
        // 오름차순/ 내림차순
        static void BubbleSort<T>(T[] DataSet, Compare<T> Comparer)
        {
            int i = 0;
            int j = 0;
            T temp;

            for (i = 0; i < DataSet.Length - 1; i++)
            {
                for (j = 0; j < DataSet.Length - (i + 1); j++)
                {
                    if (Comparer(DataSet[j], DataSet[j + 1]) > 0)
                    {
                        temp = DataSet[j + 1];
                        DataSet[j + 1] = DataSet[j];
                        DataSet[j] = temp;
                    }
                }
            }
        }

        static void Main(string[] args)
        {


            int[] numbers = { 2, 3, 4, 5, 6, 7, 1, 10, 23 };

            // 문제 1. numbers를 내림차순으로 Sorting 후 출력해보세요.

            Console.WriteLine("Sorting descending\n");
            BubbleSort<int>(numbers, delegate (int a, int b)
            {
                if (a < b) return 1;
                else if (a == b) return 0;
                else return -1;
            });

            for (int i = 0; i < numbers.Length;i++)
            {
                Console.WriteLine($"{numbers[i]}");
            }
            Console.WriteLine();

            Fruit[] fruits = new Fruit[]
             {
            new Fruit{ Name = "apple", Count = 100, brix  = 9.2f},
            new Fruit{ Name = "banana", Count = 200, brix = 7.2f },
            new Fruit{ Name = "pineapple", Count = 300, brix = 5.6f },
            new Fruit{ Name = "apple", Count = 150, brix = 4.5f},
            new Fruit{ Name = "strawberry", Count = 400, brix = 4.5f },
            new Fruit{ Name = "mango", Count = 500, brix = 3.6f },
            new Fruit{ Name = "applemango", Count = 80, brix = 9.2f }
            };


            // 문제 2. fruits를  Count멤버를 기준으로 오름차순으로 sorting 해서 출력해보세요..

            Console.WriteLine("Sorting ascending with Count\n");
            BubbleSort<Fruit>(fruits, delegate (Fruit a, Fruit b)
            {
                if (a.Count > b.Count) return 1;
                else if (a.Count == b.Count) return 0;
                else return -1;
            });

            for(int i = 0; i < fruits.Length; i++)
            {
                Console.WriteLine($"{fruits[i].Name}, {fruits[i].Count}, {fruits[i].brix}");
            }
        }
    }
}

// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _20251001_Delegate_Chain
{
    delegate void CalChain(int a, int b);
    // delegate chain: delegate에 여러개의 함수를 연결해서 일괄적으로 처리할때 사용.

    class Program
    {
        static void add(int a, int b)
        {
            Console.WriteLine($"{a} + {b} = {a+b}");
        }
        static void sub(int a, int b)
        {
            Console.WriteLine($"{a} - {b} = {a - b}");
        }
        static void mul(int a, int b)
        {
            Console.WriteLine($"{a} x {b} = {a * b}");
        }
        static void div(int a, int b)
        {
            Console.WriteLine($"{a} / {b} = {a / (float)b}");
        }

        static void Main(string[] args)
        {
            // delegate chain

            CalChain cal =
                (CalChain)Delegate.Combine(
                    new CalChain(add),
                    new CalChain(sub),
                    new CalChain(mul)
                    );

            cal(200, 300);
            Console.WriteLine();

            cal += div;

            cal(20, 30);

            cal -= div;

            Console.WriteLine();

            cal(20, 30);
        }
    }

}

// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

using System.Data;

namespace _202511001_Event
{
   // event
   // 클래스 내에 특정한 event(사건)발생했을때 외부의 이벤트 구독자(subscriber)에게 
   // 알려주는 기능을 합니다.
   // 이벤트는 event라는 키워드를 사용하여 표시하고 클래스내에서 일종의 필드처럼 정의됩니다.
   // event는 특수한 형태의 delegate
   // event에 method을 추가할때는 +=, 제거시에는 -=, =(할당은 사용이 안됨)
   class MyTimer
   {
      public delegate void Tick(DateTime now);
      public event Tick Ticked; // MyTimer 클래스내부에서 호출이 가능, event
      private int interval;
      public Tick Ticked2; //일반 delegate
      

      public MyTimer(int interval)
      {
         this.interval = interval;
      }

      public void start()
      {
         DateTime before = DateTime.Now; // 현재 시간

         while (true)
         {
            DateTime current = DateTime.Now;

            if (before.AddSeconds(interval) < current)
            {
               Ticked(current); // 이벤트는 클래스 내부에서만 호출이 가능
               before = current;
            }
         }
      }
   }

   class Monster
   {
      public void TimeEllapsed(DateTime current)
      {
         Console.WriteLine("Monster Time Ellapsed : {0}", current.ToLongTimeString());
      }

   }

   class Program
   {
      static void TimeEllapsed(DateTime current)
      {
         Console.WriteLine("Time Ellapsed : {0}", current.ToLongTimeString());
      }

      static void TimeEllapsed2(DateTime current)
      {
         Console.WriteLine("Time Ellapsed2 : {0}", current.ToLongTimeString());
      }

      static void TimeEllapsed3(DateTime current)
      {
         Console.WriteLine("Time Ellapsed3 : {0}", current.ToLongTimeString());
      }

      static void Main(string[] args)
      {
         MyTimer timer = new MyTimer(5);

         /*
         // timer에 이벤트 메소드를 추가.
         timer.Ticked += new MyTimer.Tick(TimeEllapsed);
         timer.Ticked += new MyTimer.Tick(TimeEllapsed2);



         Monster mons = new Monster();

         timer.Ticked += new MyTimer.Tick(mons.TimeEllapsed);

         timer.start();
         */

         timer.Ticked += new MyTimer.Tick(TimeEllapsed3);
         timer.Ticked(DateTime.Now); // event는 객체 외부에서 호출할 수 없습니다.
                              // 객체 내부에서만 호출이 가능합니다.


         timer.Ticked2 += new MyTimer.Tick(TimeEllapsed3);
         timer.Ticked2(DateTime.Now);



      }
   }
}

// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
namespace _202510011203_Delegate_Chain
{
   delegate void Notify(string message);

   class Notifier
   {
      public Notify EventOccured;
   }

   class EventListener
   {
      private string _name;

      public EventListener(string name)
      {
         _name = name;
      }

      public void SomethingHappend(string message)
      {
         Console.WriteLine($"{_name}.SomethingHappend: {message}");
      }
   }


   class Program
   {
      static void Main(string[] args)
      {
         Notifier notifier = new Notifier();

         EventListener listener1 = new EventListener("Listener1");
         EventListener listener2 = new EventListener("Listener2");
         EventListener listener3 = new EventListener("Listener3");

         notifier.EventOccured += listener1.SomethingHappend;    // 이벤트 구독
         notifier.EventOccured += listener2.SomethingHappend;    // 이벤트 구독
         notifier.EventOccured += listener3.SomethingHappend;    // 이벤트 구독

         notifier.EventOccured("You've got a mail");

         Console.WriteLine();


         notifier.EventOccured -= listener2.SomethingHappend;    // listener2 구독 해지
         notifier.EventOccured("Download complete!!!");

         Console.WriteLine();

         notifier.EventOccured = new Notify(listener2.SomethingHappend) + new Notify(listener3.SomethingHappend);
         notifier.EventOccured("Nuclear launch detected!!");

         Console.WriteLine();

         Notify notify1 = new Notify(listener1.SomethingHappend);
         Notify notify2 = new Notify(listener2.SomethingHappend);

         notifier.EventOccured = (Notify)Delegate.Combine(notify1, notify2);
         notifier.EventOccured("Fire!!");

         Console.WriteLine();

         notifier.EventOccured = (Notify)Delegate.Remove(notifier.EventOccured, notify2);
         notifier.EventOccured("RPG!!");



      }
   }
}

// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _20251001_GenericDelegate_Func
{
    delegate float FFunc(float a, float b);

    class Program
    {
        static float add(float a, float b)
        {
            return a + b;
        }
        static float sub(float a, float b)
        {
            return a - b;
        }
        
        static float mul(float a, float b)
        {
            return a * b;
        }

        static float div(float a, float b)
        {
            return a / b;
        }

        static float calculator(Func<float, float, float> func, float a, float b)
        {
            return func(a, b);
        }

        static void Main(string[] args)
        {
            Func<float, float, float> ffunc;

            //Func: generic delegate는 리턴타입이 있는 경우에 사용한다.

            Func<int, int, int> func;

           
            float a = 3.54f;
            float b = 10.23f;

            float ret = calculator(sub, a, b);

            Console.WriteLine($"{a} - {b} = {ret}");

            Console.WriteLine($"{a} x {b} = {calculator(mul, a, b)}");

            Func<int> func1 = () => 10;

            Console.WriteLine(func1());

            Func<int, int> func2 = (int a) => {  return a; };
            Console.WriteLine(func2(20));

            // 맨뒤에 요소가 리턴타입
            Func<int, float, float> func3 = (int a, float b)=>
            { return a / b; };

            float fret = func3(10, 1.2f);
        }
    }
}



```
