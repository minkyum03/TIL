```C#
namespace _20250915_Method_Hiding
{

    // 메소드 하이딩(Method Hiding)
    // 부모 데소드의 영향을 주지않고 특정 메서드를 다시 구형해야 하는 경우
    // 메소드 숨기기의 목적은 부모클래스의 멤버를 보호하는 것입니다.

    class Base
    {
        public void MyMethod()
        {
            Console.WriteLine("Base.MyMethod()");
        }

        public void MyMethod(string str)
        {
            Console.WriteLine($"Base.MyMethod{str}");
        }
    }

    class Derived : Base
    {
        public new void MyMethod()
        {
            Console.WriteLine("Derived.MyMethod()");
        }
    }

    class Deriveds : Derived
    {
        public new void MyMethod()
        {
            Console.WriteLine("Derived.MyMethod()");
            base.MyMethod();
        }

    }

    class MainApp
    {
        static void Main(string[] args)
        {
            Base baseObj = new Base();
            baseObj.MyMethod();

            Derived derivedObj = new Derived();
            derivedObj.MyMethod();

            Base baseOrDerived = new Derived();
            baseOrDerived.MyMethod();

        }
    }
}

// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
namespace MyExtention
{
    class Math2
    {
        public float add(int a, int b)
        {
            return a + b;
        }
        public float sub(int a, int b)
        {
            return a - b;
        }
        public int mul(int a, int b) 
        { 
            return a * b;
        }
    }
}

namespace MyExtension
{
    class exMath : MyExtention.Math2
    {
        public float div(int a, int b)
        {
            return a / b;
        }
    }
    class MainApp
    {
        static void Main(string[] args)
        {
            int a = 20;
            int b = 30;
            
            MyExtension.exMath extmath = new exMath();

            Console.WriteLine($"{a} + {b} = {extmath.add(a, b)}");
            Console.WriteLine($"{a} - {b} = {extmath.sub(a, b)}");
            Console.WriteLine($"{a} x {b} = {extmath.mul(a, b)}");

            Console.WriteLine($"{a} / {b} = {extmath.div(a, b)}");

        }
    }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _20250915_ExtentionalMethod
{
    sealed public class Math2
    {
        public int add(int x, int y)
        {
            return x + y;
        }

        public int sub(int x, int y)
        {
            return x - y;
        }
    }

    public static class Math2Extention
    {
        public static float div(this Math2 myMath, int a, int b)
        {
            return a / (float)b;
        }
    }

    public static class Math2Extention2
    {
        public static float mul(this Math2 myMath, int a, int b)
        {
            return a * b;
        }
    }
    internal class Progeam
    {
        //확장 메소드
        //기존 클래스의 기능을 확장하는 기능 (상속x)

        static void Main(string[] args)
        {
            int a = 20;
            int b = 30;

            Math2 math2 = new Math2();

            float ret = math2.add(a, b);
            Console.WriteLine($"{a} + {b} = {ret}");

            ret = math2.sub(a, b);
            Console.WriteLine($"{a} - {b} = {ret}");

            ret = math2.div(a, b);
            Console.WriteLine($"{a} / {b} = {ret}");

            ret = math2.mul(a, b);
            Console.WriteLine($"{a} x {b} = {ret}");
        }
    }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

using MyExtension;

namespace MyExtension
{
   public static class IntegerExtension
   {
      public static int Square(this int myInt)
      {
         return myInt * myInt;
      }

      public static int Power(this int myInt, int exponent)
      {
         int result = myInt;
         for (int i = 1; i < exponent; i++)
            result = result * myInt;

         return result;
      }
   }

   public static class FloatExtension
   {
      public static float Squre(this float myInt)
      {
         return myInt * myInt;
      }
   }

   // double형 확장 메소드 Square 
   public static class DoubleExtension
   {
      public static double Squre(this double myInt)
      {
         return myInt * myInt;
      }
   }

   // string형 문자열을 매개변수에 전달된 횟수만큼 출력하는 확장메소드

   public static class StringExtension
   {
      public static void Print(this string myStr, int num)
      {
         for (int i = 0; i < num; i++)
         {
            Console.WriteLine($"{myStr}");
         }
      }
   }
}

namespace ExtensionMethod
{
   class MainApp
   {
      static void Main(string[] args)
      {

         Console.WriteLine($"{3}^2 : {3.Square()}");
         Console.WriteLine($"{3}^{4} : {3.Power(4)}");
         Console.WriteLine($"{2}^{10} : {2.Power(10)}");

         Console.WriteLine($"{3.14}^2 : {(3.14f).Squre()}");

         Console.WriteLine($"{10.11}^2: {(10.11).Squre()}"); // Double Square

         ("monster").Print(10); // String


      }
   }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

   // Object class에 기본적으로 제공되어지 Method가 있습니다.

   // public static bool Equals(Object? objA, Object? objB);   // 참조형객체의 경우 참조값을 비교
   // 값타입 객체의 경우 값비교합니다.
   // public virtual bool Equals(Object? obj);

   // public virtual int GetHashCode();    // 특정 인스턴스를 고유하게 식별할 수 있는
   // 4byte int형 코드값을 반환한다.
   // public Type GetType();   // 인스턴스에서 타입을 얻어낸다.
   // public virtual string? ToString();   // 기본적으로 해당 인스턴스가 속한 크래스의 
   // 전체이름을 반환한다.
   // 각 클래스들이 override해서 각 클래스마다 다르게 작동
   // 할 수 있습니다.

   // protected Object MemberwiseClone(); 객체를 복사할때 사용.

namespace _202509151200_object_class
{   
   // Object class
   // C#에서는 모든 클래스는 최상위 클래스(superset)인 Object에서 상속을 받습니다.
   // 기본 제공 데이타 타입이나 사용자 정의 클래스도 자동으로 Object 클래스에서 상속됩니다.

   class A
   {
      public int _value;      
      
      public A(int value)
      {   
         _value = value;
      }
   }

   class B : A
   {
      public B(int value)
         : base(value)
      {

      }

   }

   class C : B
   {
      public C(int value)
         : base(value)
      {

      }

   }


   class Program
   {

      static void Main(string[] args)
      {
         //Object
         A aObj = new A(10);
         B bObj = new B(20);
         C cObj = new C(30);

         Console.WriteLine($"aObj.toString() = {aObj.ToString()}");
         Console.WriteLine($"aObj.toString() = {bObj.ToString()}");
         Console.WriteLine($"aObj.toString() = {cObj.ToString()}");

         Console.WriteLine($"aObj.toString() = {aObj.GetType().FullName}");
         Console.WriteLine($"aObj.toString() = {bObj.GetType().IsClass}");
         Console.WriteLine($"aObj.toString() = {cObj.GetType().IsArray}");



         A aaObj = new A(10);

         A refaaObj = aaObj;


         bool isEqual = aaObj.Equals(aObj);

         Console.WriteLine($"isEqual = {isEqual}");

         isEqual = aaObj.Equals(refaaObj);

         Console.WriteLine($"isEqual = {isEqual}");


         isEqual = object.Equals(aaObj, aObj);
         Console.WriteLine($"isEqual = {isEqual}");

         // 값타입 비교.

         int a = 3;
         int b = 3;

         bool ret = a.Equals(b);

         Console.WriteLine($"ret = {ret}");



      }
   }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
using System;

namespace _202509151206_UpCasting
{

   class Parent
   {
      private int _value;

      public Parent(int value)
      {
         _value = value;
      }

      public void Print()
      {
         Console.WriteLine($"Parent::Print() value = {_value}");
      }

   }

   class Child : Parent
   {
      private int _value2;

      public Child(int value1, int value2)
         : base(value1)
      {
         _value2 = value2;
      }

      public new void Print()
      {
         base.Print();
         Console.WriteLine($"Child::Print() _value2 = {_value2}");
      }
   }

   class Child2 : Parent
   {
      private int _value2;

      public Child2(int value1, int value2)
         : base(value1)
      {
         _value2 = value2;
      }

      
        public new void Print()
        {
            base.Print();
            Console.WriteLine($"Child2::Print() _value2 = {_value2}");
        }
        
   }


   class Program
   {
      static void Main(string[] args)
      {
         Parent parent1 = new Child(10, 200); // UpCasting : 자식 객체를 부모의 타입으로 받는 것.

         parent1.Print();    // Parent 타입의 Print() 메소드가 호출
                        //parent1._value

         Parent parent2 = new Child2(20, 300);

         parent2.Print(); // Parent 타입의 Print() 메소드 호출


         //Child child = new Parent(20);  // 다운캐스팅 : 부모타입을 자식 타입에 대입하는 것
         // 다운 캐스팅은 원칙적으로 허용이 되지 않습니다.


         Child cchild = (Child)parent1; // 이런형태의 다운 캐스팅은 허용이 됩니다.
                                 // parent1이 가르키고 있던게 Child 타입이었기 때문에
         cchild.Print(); // Child Print함수가 호출

         Child2 child2 = (Child2)parent2;
         child2.Print();

      }
   }
}




```
