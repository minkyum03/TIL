```C#
namespace _20250924_OperatorOverloading
{
    // 연산자 오버로딩
    // 사용자가 만든 DataType에 연산기호를 사용하는 방법을 제공하는것

    class Complex
    {
        private int _real;
        private int _imginary;

        public Complex(int real, int imginary)
        {
            _real = real;
            _imginary = imginary;
        }

        public static Complex operator +(Complex left, Complex right)
        {
            return new Complex(left._real + right._real, left._imginary + right._imginary);
        }

        public static Complex operator -(Complex left, Complex right)
        {
            return new Complex(left._real - right._real, left._imginary - right._imginary);
        }

        public override string ToString()
        {
            if(_imginary < 0)
            {
                return $"{_real}{_imginary}i";
            }
            else
            {
                return $"{_real}+{_imginary}i";
            }
        }


        public static bool operator <(Complex left, Complex right)
        {
            return left._real < right._real;
        }

        public static bool operator >(Complex left, Complex right)
        {
            return left._real > right._real;
        }

    }

    class Program
    {
        static void Main(string[] args)
        {
            Complex a = new Complex(10, 10);
            Complex b = new Complex(10, -20);

            Complex c = a + b;

            Console.WriteLine($"{a} + {b} = {c.ToString()}");


            c = a - b;
            Console.WriteLine($"{a} - {b} = {c.ToString()}");

            bool ret = a > b;
            Console.WriteLine($"{a} > {b} = {ret}");

            ret = a < b;
            Console.WriteLine($"{a} < {b} = {ret}");

            ret = a < c;
            Console.WriteLine($"{a} < {c} = {ret}");
        }
    }
}

// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _20250924_OperatorOverloading
{
    class Door
    {
        private bool _isOpen = false;

        public bool isOpen { get => _isOpen; }

        public Door(bool isOpen)
        {
            _isOpen = isOpen;
        }

        /*
        public static implicit operator bool(Door c) //  묵시적 형변환
        {
            return c.isOpen;
        }
        */

        // explicit은 묵시적 형변환을 허용하지 않는다.
        // 명시적 형변환만 허용함.
        public static explicit operator bool(Door c) //  명시적 형변환
        {
            return c.isOpen;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Door door = new Door(true);

            if(door.isOpen)
            {
                Console.WriteLine("문이 열려있습니다.");
            }
            else
            {
                Console.WriteLine("문이 닫혀있습니다.");
            }

            if ((bool)door) // door만 사용할 땐 묵시적형변환 , 앞에 bool까지 붙여야 명시적 형변환
            {
                Console.WriteLine("문이 열려있습니다.");
            }
            else
            {
                Console.WriteLine("문이 닫혀있습니다.");
            }
        }
        
        
    }
}


// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace Custom
{
    class Test
    {
        public int _intNum;
        public float _floatNum;

        public Test(int intNum, float floatNum)
        {
            _intNum = intNum;
            _floatNum = floatNum;
        }

        public override string ToString()
        {
            return $"_intNum = {_intNum}, _floatNum = {_floatNum}";
        }
    }


    class Number
    {
        int _intNum;
        float _floatNum;
        double _doubleNum;
        string _stringNum;


        public Number(int intNum, float floatNum, double doubleNum, string stringNum)
        {
            _intNum = intNum;
            _floatNum = floatNum;
            _doubleNum = doubleNum;
            _stringNum = stringNum;
        }

        // 아래 Main 함수의 코드가 작동하도록 형변환 연산자를 만들어 넣으세요.
        // 명시적 형변환을 하세요....

        public static explicit operator int(Number number)
        {
            return number._intNum;
        }
        public static implicit operator float(Number number)
        {
            return number._floatNum;
        }
        public static implicit operator double(Number number)
        {
            return number._doubleNum;
        }
        public static implicit operator string(Number number)
        {
            return number._stringNum;
        }
        public static implicit operator Test(Number number)
        {
            return new Test(number._intNum, number._floatNum);
        }
    }
}




namespace _202509231654_OperatorOverloading
{
    class Program
    {
        static void Main(string[] args)
        {
            Custom.Number number = new Custom.Number(100, 12.23f, 1234.45, "일백만원");

            int num = (int)number;
            float fnum = (float)number;
            double dnum = (double)number;
            string snum = (string)number;
            Custom.Test test = (Custom.Test)number;

            Console.WriteLine($"num = {num}, fnum = {fnum}, dnum = {dnum}, snum = {snum}");
            Console.WriteLine($"Custom.Test = {test}");




        }
    }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
using System;
using System.Numerics;

namespace _202509241343_OperatorOverloading_Exer
{
   public class Vector2D
   {
      public double X { get; private set; }
      public double Y { get; private set; }

      // 생성자
      public Vector2D(double x, double y)
      {
         X = x;
         Y = y;
      }
        public override string ToString()
        {
            return $"(x = {X}, y = {Y})";
        }

      // 아래 Main에 있는 코드가 작동하도록 연산자 오버로딩 메소드를 만드시고
      // 작동 시켜 보세요...

      public static Vector2D operator +(Vector2D a, Vector2D b)
        {
          return new Vector2D(a.X + b.X, a.Y + b.Y);
        }
        
        public static Vector2D operator -(Vector2D a, Vector2D b)
        {
            return new Vector2D(a.X - b.X, a.Y - b.Y);
        }
       
        public static Vector2D operator *(Vector2D a, float b)
        {
            return new Vector2D(a.X * b, a.Y * b);
        }

        public static Vector2D operator *(float a, Vector2D b)
        {
            return new Vector2D(a * b.X, a * b.Y);
        }
        
        public static Vector2D operator /(Vector2D a, float b)
        {
            if(b == 0)
            {
                return null;
            }
            else
            {
                return new Vector2D(a.X / b, a.Y / b);
            }
        }

    }

   // 테스트 프로그램
   public class Program
   {
      public static void Main(string[] args)
      {
         Console.WriteLine("=== Vector2D 클래스 테스트 ===\n");

         // 벡터 생성
         Vector2D v1 = new Vector2D(3, 4);
         Vector2D v2 = new Vector2D(1, 2);
         Vector2D v3 = new Vector2D(-2, 1);

         Console.WriteLine($"v1 = {v1}");
         Console.WriteLine($"v2 = {v2}");
         Console.WriteLine($"v3 = {v3}");


         Console.WriteLine("\n=== 벡터 덧셈과 뺄셈 ===");
         Vector2D sum = v1 + v2;
         Console.WriteLine($"{v1} + {v2} = {sum}");

         Vector2D diff = v1 - v2;
         Console.WriteLine($"{v1} - {v2} = {diff}");

         Console.WriteLine("\n=== 스칼라 곱셈과 나눗셈 ===");
            Vector2D scaled = v1 * 2.5f;
            Console.WriteLine($"{v1} × 2.5 = {scaled}");

            Vector2D divided = v1 / 2;
         Console.WriteLine($"{v1} ÷ 2 = {divided}");

         Vector2D scaled2 = 3 * v2;
         Console.WriteLine($"3 × {v2} = {scaled2}");


      }
   }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
using System;

namespace _202509241343_OperatorOverloading_Exer
{
    public class Vector2D
    {
        public double X { get; private set; }
        public double Y { get; private set; }

        // 생성자
        public Vector2D(double x, double y)
        {
            X = x;
            Y = y;
        }

        // 아래 Main에 있는 코드가 작동하도록 연산자 오버로딩 메소드를 만드시고
        // 작동 시켜 보세요...

        // 벡터 덧셈
        public static Vector2D operator +(Vector2D left, Vector2D right)
        {
            return new Vector2D(left.X + right.X, left.Y + right.Y);
        }

        // 벡터 뺄셈
        public static Vector2D operator -(Vector2D left, Vector2D right)
        {
            return new Vector2D(left.X - right.X, left.Y - right.Y);
        }


        // 스칼라 곱셈
        public static Vector2D operator *(Vector2D left, double scalar)
        {
            return new Vector2D(left.X * scalar, left.Y * scalar);
        }

        public static Vector2D operator *(double scalar, Vector2D right)
        {
            return new Vector2D(right.X * scalar, right.Y * scalar);
        }

        // 스칼라 나눗셈
        public static Vector2D operator /(Vector2D left, double scalar)
        {
            /*

            double x = left.X / scalar;
            double y = left.Y / scalar;

            Vector2D vec = new Vector2D(x , y);
            */


            if (scalar == 0)
            {
                //throw new DivideByZeroException("벡터를 0으로 나눌수 없음~~");

                throw new Exception("0으로 나누지마");
            }


            return new Vector2D(left.X / scalar, left.Y / scalar);
        }

        // ToString 메서드 오버라이드
        public override string ToString()
        {
            return $"({X:F2}, {Y:F2})";
        }
    }

    // 테스트 프로그램
    public class Program
    {
        public static void Main(string[] args)
        {
            Console.WriteLine("=== Vector2D 클래스 테스트 ===\n");

            // 벡터 생성
            Vector2D v1 = new Vector2D(3, 4);
            Vector2D v2 = new Vector2D(1, 2);
            Vector2D v3 = new Vector2D(-2, 1);

            Console.WriteLine($"v1 = {v1}");
            Console.WriteLine($"v2 = {v2}");
            Console.WriteLine($"v3 = {v3}");


            Console.WriteLine("\n=== 벡터 덧셈과 뺄셈 ===");
            Vector2D sum = v1 + v2;
            Console.WriteLine($"{v1} + {v2} = {sum}");

            Vector2D diff = v1 - v2;
            Console.WriteLine($"{v1} - {v2} = {diff}");

            Console.WriteLine("\n=== 스칼라 곱셈과 나눗셈 ===");
            Vector2D scaled = v1 * 2.5;
            Console.WriteLine($"{v1} × 2.5 = {scaled}");

            try
            {
                Vector2D divided = v1 / 0;
                Console.WriteLine($"{v1} ÷ 2 = {divided}");
            }
            catch (DivideByZeroException exception)
            {
                Console.WriteLine($"message: {exception.Message}");
            }
            catch (Exception exception)
            {
                Console.WriteLine($"message: {exception.Message}");
            }



            Vector2D scaled2 = 3 * v2;
            Console.WriteLine($"3 × {v2} = {scaled2}");


        }
    }
}





```
