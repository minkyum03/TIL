# 유니티 수업 시작

## 🧭 배경 & 용어 빠르게 정리

DirectX ≠ Direct3D: DirectX는 묶음 이름, 3D는 보통 Direct3D가 담당

OpenGL(오픈지엘), Vulkan, Metal 등 대안 API 존재

DOOM(1993): 3D 가속 카드가 아니라 CPU 소프트웨어 렌더링(2.5D)

## 3D 기하

Vertex(정점): 보통 (x, y, z)

Edge(에지): 정점 2개 연결 선분

Face(면): 보통 삼각형(표준 단위)

Polygon: 다각형(삼각형 포함) → Mesh는 다수 폴리곤의 집합

## 좌표계 & 변환

Local/Model → World → View(Camera) → Clip/Projection → NDC → Viewport

변환은 행렬 곱으로 누적(TRS).

ℹ️ Rigid(강체) 변환은 이동·회전만 해당, 스케일은 거리/각도 보존 안 해서 비-강체. 엔진에선 편의상 함께 다뤄 아핀 변환이라 부른다.

## 🖼️ 렌더링 파이프라인 한 장(요약)
```css
Vertices (Local)
   └─[Model→World]─────► World
        └─[World→View]────► View (Camera space)
             └─[Projection]──► Clip → Clipping → NDC
                 └─[Viewport map]──► Screen pixels
                      └─ Rasterization ─► Fragments
                           └─ Pixel/Fragment Shader ─► Output(Blend/Depth/Stencil)
```

정점 셰이더: 위치 변환/기초 계산

지오메트리/테셀레이션: 옵션 단계(프리미티브 증감/세분화)

래스터라이즈: 삼각형 → 픽셀 후보

픽셀(프래그먼트) 셰이더: 최종 색(조명/텍스처)

렌더 백엔드: 테스트·블렌딩·쓰기

## 💡 조명 & 머티리얼(기초)
구분	의미
Ambient(주변광)	전체 바탕 밝기
Diffuse(확산)	표면-광원 각도에 따른 밝기
Specular(반사)	하이라이트/반짝임
Emissive(자발광)	스스로 빛나는 효과

### Light 타입

Directional: 태양처럼 ‘방향만’ 중요(위치 무관)

Point: 한 점에서 전방위, 거리 감쇠

Spot: 원뿔 범위/각도

현대 엔진은 PBR(Albedo/Metallic/Roughness/Normal/Emission…) 기반이 표준

## 🧪 실습: 코드로 삼각형 만들기

폴더 권장: Assets/Scripts/TriangleCreator.cs
빈 GameObject에 붙이면 자동으로 MeshFilter / MeshRenderer를 요구한다.

``` csharp
using UnityEngine;

[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class TriangleCreator : MonoBehaviour
{
    void Start()
    {
        CreateTriangle();
    }

    private void CreateTriangle()
    {
        // 1) 정점
        Vector3[] vertices =
        {
            new Vector3(-1f, -1f, 0f),
            new Vector3( 0f,  1f, 0f),
            new Vector3( 1f, -1f, 0f),
        };

        // 2) 인덱스(삼각형 1개)
        int[] triangles = { 0, 1, 2 };

        // 3) UV (텍스처 대비)
        Vector2[] uvs =
        {
            new Vector2(0f, 0f),
            new Vector2(0.5f, 1f),
            new Vector2(1f, 0f),
        };

        // 4) 메시 생성
        var mesh = new Mesh { name = "ProceduralTriangle" };
        mesh.vertices = vertices;
        mesh.triangles = triangles;
        mesh.uv = uvs;

        mesh.RecalculateNormals();
        mesh.RecalculateBounds();
        mesh.RecalculateTangents();

        // 5) 컴포넌트 적용
        var mf = GetComponent<MeshFilter>();
        var mr = GetComponent<MeshRenderer>();
        mf.sharedMesh = mesh;

        // 6) 머티리얼(파이프라인 맞춰 셰이더 선택)
        Shader shader = Shader.Find("Standard");
        if (shader == null) shader = Shader.Find("Universal Render Pipeline/Lit");
        mr.sharedMaterial = new Material(shader);
    }
}

```


## 🧷 버퍼 & 컬링 메모

Vertex Buffer: 정점 속성 묶음(포지션/노멀/UV/컬러 등)

Index Buffer: 정점 재사용(메모리/캐시 효율↑)

Winding Order: 시계/반시계 방향에 따라 앞/뒷면 결정 → Back-Face Culling으로 성능↑

## 🐞 흔한 실수 & 빠른 디버깅

클래스명 ≠ 파일명 → 컴포넌트로 붙지 않음

MonoBehaviour 상속 누락 → 인스펙터에 안 보임

URP/HDRP인데 Standard 셰이더 찾기 실패 → 파이프라인 전용 셰이더 사용

Update() 이동에 Time.deltaTime 누락 → 프레임 종속

Scene 저장/등록 누락 → Build Settings > Scenes In Build 확인


<details> <summary><b>원문 메모에서 수정/보완한 핵심</b> (펼치기)</summary>

“opengle” → OpenGL 표기 수정

좌표 표기 (x, y, z) 로 통일

DOOM = 소프트웨어 렌더링(2.5D) 로 정확화

스케일 ≠ 리지드 변환(거리/각도 보존 X) 명확화

파이프라인 단계와 셰이더 매핑을 현대 기준으로 재정리

Unity 코드에 UV/탱전트, 파이프라인별 셰이더 대체 로직 추가

</details>
