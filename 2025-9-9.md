```C#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _20250908_enCapsulation
{
    // 동사무소에서 필요한 손흥민의 정보는?
    // 주소 나이 이름, 가족관계, 성별, 주민번호


    //대상객체 -> 추상화 -> Data -> class 키워드로 묶음 -> 캡슐화 -> 클래스형 DataType을 만듦. 변수(객체)

    // class 클래스명 {
    //     데이타;
    // }
    class Son // 캡슐화
    {
        // 접근제어자
        // 객체안에 멤버에 접근을 허용하거나 허용하지 않거나 하는 것을 접근제어자라고 합니다.
        // 갭슐화의 기본 정책은 정보은닉
        // private: 외부에서 접근하는 것을 허용하지 않음, 자식이 접근하는 것도 허용하지 않음( 기본)
        // protected: 자식이 접근하는 것은 허용, 외부에서 접근하는 것은 허용하지 않음
        // public: 외부에서 접근하는 것을 허용하겠다.
        private string address = ""; // 멤버필드
        private int age;
        private string name = "";
        private bool sungbyul;
        private string juminNum = "";

        public string Address
        {
            get { return address; }
            set { address = value; }
        }
        public int Age
        {
            get => age; 
            set => age = value;
        }

        public string Name
        {
            get => name;
            set => name = value;
        }
        public bool Sungbyul
        {
            get => sungbyul;
            set => sungbyul = value;
        }
        public string JuminNum
        {
            get
            {
                return juminNum;
            }
            set => juminNum = value;
        }  // 멤버필드를 직접 접근하는 것을 허용하지 말라고 합니다. (권고사항)
           // property를 통해서 접근하도록 해라
           // property 사용시 장점 1. 데이터의 무결성(정확성, 일관성, 유효성) / 2, 디버깅 작용이 용이하다.
    }



    internal class Program
    {
        static void Main(string[] args)
        {
            // 값타입: 기본 데이터 타입, 구조체 , 열거체(스텍영역에 만들어지는 변수로
            //할당받은 메모리공간의 비트값을 값으로 사용하는 형태)
            // 참조타입: string, 클래스형 DataType, array(동적메모리(Heap)에
            //값을 저장하는 공간을 할당하고 주소를 참조헤서 접근하는 형태

            // C#에서는 클래스형 DataType 변수(객체)를 값으로 만들 수 없다.
            //클래스형 DataType변수는 동적으로만 만들 수 있음
            Son a = new Son(); // 클래스형 DataType Son으로 객체 a를 만듦.

            a.Age = 32;
            a.Name = "손흥민";
            a.Sungbyul = false;
            a.JuminNum = "0000000";
            a.Address = "런던";

            Console.WriteLine($"son 나이: {a.Age}");
            Console.WriteLine($"son 이름: {a.Name}");
            Console.WriteLine($"son 주민번호: {a.JuminNum}");
            string sungbyul = a.Sungbyul ? "여자" : "남자";
            Console.WriteLine($"son 성별: {sungbyul}");
            Console.WriteLine($"son 주소: {a.Address}");

        }
    }
}
//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
namespace _20250909_Property
{

    class Car
    {
        private string modelName = ""; // 멤버필드
        private int wheelCount = 4;
        //private int speed;
        private bool isCargo = true;

        public string ModelName
        {
            set // private set {~}로 설정하면 외부에서 값을 바꾸지 못함
            {
                modelName = value;
            }

            get
            {
                return modelName;
            }
        }

        public int WheelCount
        {
            get => wheelCount;
        }

        public int Speed { set; get; }   // 자동 구현 Property

        public string IsCargo
        {
            get
            {
                if (isCargo)
                {
                    return "짐칸있음";
                }
                else
                {
                    return "짐칸없음";
                }
            }
        }


    }
    internal class Program
    {
        static void Main(string[] args)
        {
            Car car = new Car();

            // Car 클래스에 멤버필드 각각에 property를 만들고 
            // 값을 저장한 후에 출력해보세요..

            car.ModelName = "포터";
            car.Speed = 200;

            Console.WriteLine($"모델명: {car.ModelName}");
            Console.WriteLine($"바퀴수: {car.WheelCount} 개");
            Console.WriteLine($"최고속도: {car.Speed} km/h");
            Console.WriteLine($"짐칸유무: {car.IsCargo}");

        }
    }
}

// ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _20250909_Method
{
    // C#언어는 완벽한 객체지향 언어로 모든 것이 다 객체로 이루어져 있습니다. 
    // 객체는 멤버필드(속성)과 메소드(액션, 행위)로 구성되어있습니다.
    // 속성(attribute): 다른 객체와 구별되어지는 데이타를 말합니다.
    // 액션(behaviour): 객체의 행동을 구성합니다.

    // 액션은 메소드로 표현됩니다.

    // 메소드는
    // returnType 메소드명(매개변수){
    //      명령어들;
    // }

    // returnType 메소드가 묶어놓은 명령어들을 처리하고 결과값을
    // return 값이 없는경우에는 void로 지정하면됩니다.
    // returnType이 있는 경우에는 메소드의 블럭 안에 return문이 있어야 합니다.
    // 어떤 DataType으로 전달할 건지.
    // 메소드명 메소드를 호출할때 사용할 이름
    // 매개변수(parameter): 메소드를 호출할때 전달할 인자값(argument)을 받는 변수



    class Calculator
    {
        public int add(int a, int b)
        {
            int temp = a + b;
            return temp;
        }

        public int sub(int a, int b)
        {
            return a - b;
        }

        public void printName()
        {
            Console.WriteLine("Calculator");
        }

    }
    internal class Program
    {
        static void Main(string[] args)
        {
            int a = 20;
            int b = 30;



            Calculator cal = new Calculator();

            int ret = cal.add(a, b); // 메소드는 객체를 통해서만 호출할 수 있습니다.
            Console.WriteLine($"{a} + {b} = {ret}");

            ret = cal.sub(a, b);
            Console.WriteLine($"{a} - {b} = {ret}");

            cal.printName();
        }
    }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _202509091542_NamedParam
{
   class Program
   {
      // Named Parameter (명명된 인수)
      // 메소드 호출시 매개변수의 이름을 명시하여 매개변수에 데이터를 바인딩하는 기능

      static void PrintInfo(string name, string phone, int age)
      {
         Console.WriteLine("이름: {0}, 전화번호: {1}, 나이: {2}", name, phone, age);
      }

      static void Main(string[] args)
      {
         PrintInfo(name: "손흥민", phone: "1111- 1111", 32);
         PrintInfo(phone: "1111 - 1111", name: "손흥민", age: 32);
         PrintInfo("손흥민", "1111-1111", age: 32);

      }
   }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _20250909_OptionalParam
{
    internal class Program
    {
        // Optional parameter(선택적 매개변수)
        // 메소드 선언시 매개변수에 기본값을 할당
        // 호출자가 인수를 입력하지 않은 경우 메소드는 기본값이 할당된 매개변수를 사용
        // 호출자는 해당 매개변수에[ 대한 인수 입력여부를 선택하여 호출할 수 있습니다.
        static void PrintMergeName(string name, string nickName = "바보")
        {
            Console.WriteLine("{0}은 {1}이다", name, nickName);
        }


        static void Main(string[] args)
        {
            PrintMergeName("몬스터");
            PrintMergeName("몬스터", "천재");
            PrintMergeName(name: "몬스터");
            PrintMergeName(name: "몬스터", nickName: "천재");
        }
    }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _20250909_UsingParam
{
    internal class Program
    {
        // 가변길이 인수
        // 인수의 갯수를 유연하게 사용할 수 있습니다.
        // params 키워드와 배열을 이용해서 선언하면 됩니다.
        // 데이터의 형식이 같다면 가변길이 인수를 통해 오버로딩 대신 사용할 수 있음.

        static int Sum(params int[] args)
        {
            int sum = 0;
            for (int i = 0; i < args.Length; i++)
            {
                sum += args[i];
            }

            return sum;
        }

        static string Sum(params string[] args)
        {
            string sum = "";
            for (int i = 0; i < args.Length; i++)
            {
                sum += args[i] + ", ";
            }

            return sum;
        }

        static void Main(string[] args)
        {
            int sumValue = 0;

            sumValue = Sum(1, 2);
            Console.WriteLine($"Sum = {sumValue}");

            sumValue = Sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
            Console.WriteLine($"Sum = {sumValue}");


            string fruits = Sum("배", "사과");
            Console.WriteLine($"fruits = {fruits}");


            fruits = Sum("apple", "banana", "pineApple", "mango");
            Console.WriteLine($"fruits = {fruits}");

            string[] ff = { "potato", "apple", "banana", "pineApple", "mango" };

            fruits = Sum(ff);
            Console.WriteLine($"fruits = {fruits}");

        }
    }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _20250909_LocalFunction
 {
    internal class Prograam
    {
        // 로컬함수(Local Function)
        static string ToLowerString(string input)
        {
            var arr = input.ToCharArray();
            for (int i = 0; i < arr.Length; i++)
            {
                arr[i] = ToLowerChar(i);
            }

            // 지역함수
            char ToLowerChar(int i)
            {
                if (arr[i] < 65 || arr[i] > 90) // A~Z의 ASCII 값 : 65 : 90
                    return arr[i];
                else // a~z의 ASCII 값 : 97 : 122
                    return (char)(arr[i] + 32);
            }

            return new string(arr);
        }


        static void Main(string[] args)
        {
            Console.WriteLine(ToLowerString("Hello!"));
            Console.WriteLine(ToLowerString("Good Morning."));
        }
    }
}

//ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

namespace _20250909_Overloading
{
    // 오버로딩(Overloading)
    // 같은 이름의 메소드(함수)를 만드는 것
    // 매개변수의 데이타 타입이 달라야 합니다.
    // 리턴 타입은 함수이름에 포함되지 않습니다.
    // 오버로딩은 다형성의 도구입니다.
    class Add
    {
        public int add(int a, int b) // addXX
        {
            return a + b;
        }

        /*
        public float add(int a, int b)
        {
           return a + b;
        }
        */


        public float add(float a, float b) // addYY
        {
            return a + b;
        }

        public double add(double a, double b) // addZZ
        {
            return a + b;
        }

        public string add(string a, string b) // addSS
        {
            return a + b;
        }
    }


    class Program
    {
        static void Main(string[] args)
        {
            int a = 10;
            int b = 20;

            float c = 3.4f;
            float d = 4.5f;

            double e = 10.2d;
            double f = 32.3d;

            string g = "monster";
            string i = " is World!!";

            Add add = new Add();

            Console.WriteLine($"{a} + {b} = {add.add(a, b)}"); // call add.addXX
            Console.WriteLine($"{c} + {d} = {add.add(c, d)}");  // call add.addYY
            Console.WriteLine($"{e} + {f} = {add.add(e, f)}");
            Console.WriteLine($"{g} + {i} = {add.add(g, i)}");
        }
    }
}

```
