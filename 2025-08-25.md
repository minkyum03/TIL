### TIL — 자료구조/시퀀스 기본 (2025-08-25)
## 1) 자료구조(Data Structure)
- 정의: 데이터를 효율적으로 저장·조회·수정·삭제하기 위한 구조와 방법.

선택 기준: 접근/탐색 속도, 삽입/삭제 비용, 메모리 사용량, 불변성 필요 여부.

### 파이썬에서 자주 쓰는 것

* 시퀀스: ```list(뮤터블), tuple(이뮤터블), str(이뮤터블)```
* 집합형: ```set, frozenset```
* 매핑: ```dict```
* 큐/스택 유틸: ```collections.deque```

### 빅오(대략)
* 인덱스 접근(list/tuple): ```O(1)```
* 맨 뒤 삽입(list.append): ```평균 O(1)```
* 중간 삽입/삭제(list): ```O(n)```
* 슬라이싱 생성: ```O(k)``` (잘라내는 길이에 비례)

## 2) 배열(Array)
- 파이썬의 리스트는 동적 배열(가변 길이, 임의 접근 ```O(1)```).
- 고정 타입 배열이 필요하면 array 모듈, 대규모 수치 계산엔 ```numpy.ndarray``` 사용.
- 입문 단계에서는 리스트 = 배열로 생각해도 무방.
```python
# 동적 배열로서의 리스트
a = [10, 20, 30]
a.append(40)     # 평균 O(1)
x = a[2]         # O(1)
```
## 3) 리스트(List)
- 특징: 순서 유지, 중복 허용, 뮤터블(수정 가능).
- 주요 메서드: ```append```, ```extend```, ```insert```, ```pop```, `remove`, `sort`, `reverse`
- 복사 주의: `b = a`는 같은 리스트를 가리킴(얕은 복사 아님). 복사하려면 `a.copy()`나 `a[:]`.
```pythpn
a = [1, 2, 3]
b = a            # 같은 객체
c = a[:]         # 새로운 리스트(얕은 복사)
a[0] = 99
print(b)         # [99, 2, 3]
print(c)         # [1, 2, 3]
```
## 4) 튜플(Tuple)
- 특징: 순서 유지, 중복 허용, 이뮤터블(불변).
- 용도: 변경되면 안 되는 데이터, 딕셔너리 키, 다중 반환 등.
- 패킹/언패킹 지원, 원소 1개 튜플은 꼬리 쉼표 필수: (1,)
```python
t = (1, 2, 3)
# t[0] = 10  # TypeError (불변이므로 수정 불가)

x, y = (10, 20)  # 언패킹
single = (42,)   # 1원소 튜플
```
## 5) 인덱스로 원소에 접근하기
- 0부터 시작, 음수 인덱스는 뒤에서 접근(`-1`은 마지막).
- 범위를 벗어나면 `IndexError`.
```python
a = [10, 20, 30, 40]
a[0]    # 10
a[-1]   # 40
# a[4]  # IndexError
```
## 6) 인덱스식 사용하기(계산식/표현식으로 인덱싱)

- 인덱스에 표현식을 넣어 동적 접근 가능(`i+1`, `len(a)-1`, 조건식 등).
```pyhon
a = [10, 20, 30, 40]
i = 1
print(a[i+1])        # 30
print(a[len(a)-1])   # 40 (마지막)
j = -2
print(a[j])          # 30
```
## 7) 슬라이스식으로 원소에 접근하기 (읽기)
- 문법: `seq[start:stop:step]` (반개구간, start 포함 ~ stop 제외)
- 생략 가능: `[:stop]`, `[start:]`, `[:]`(복사)
- 음수 step로 역순 가능.
```pyhon
a = [0, 1, 2, 3, 4, 5]
a[1:4]     # [1, 2, 3]
a[:3]      # [0, 1, 2]
a[3:]      # [3, 4, 5]
a[::-1]    # [5, 4, 3, 2, 1, 0] (역순 복사)
```
### 복사/메모리
- 슬라이스 결과는 새로운 시퀀스를 만들어냄(리스트→리스트, 튜플→튜플).
- 길이 `k`만큼 시간/메모리 비용 발생: `O(k)`.

## 8) 슬라이스식으로 원소 꺼내기 vs 대입(쓰기)
- **꺼내기(읽기)**는 위와 같이 새 객체를 반환.
- **대입(쓰기)**은 해당 구간을 치환(리스트만 가능).
```pyhon
a = [0, 1, 2, 3, 4, 5]
part = a[2:5]         # [2, 3, 4] (새 리스트)
a[2:5] = [20, 30]     # 길이 달라도 치환 가능
# a == [0, 1, 20, 30, 5]
a[:] = []             # 전체 비우기
# a == []
```

튜플/문자열은 이뮤터블이라 슬라이스 대입 불가.

## 9) 뮤터블과 이뮤터블의 대입(할당) — 핵심 이해
- 파이썬의 대입은 이름(name) → 객체(object) 의 참조를 연결.
- 뮤터블(list, dict, set 등): 객체 내용 변경 가능
- 이뮤터블(int, float, str, tuple 등): 객체 내용 변경 불가
- 대입으로 복사되지 않음. 같은 객체를 가리키면 한쪽 변경이 다른 쪽에 보임(뮤터블만).
```pyhon
# 같은 리스트를 가리키는 예
a = [1, 2]
b = a
a.append(3)
print(b)        # [1, 2, 3]  (같은 객체)

# 이뮤터블(정수) 예
x = 10
y = x
x += 1
print(y)        # 10 (x가 11인 새 int로 바뀌었을 뿐, y는 이전 객체 10을 가리킴)
```
```pyhon
얕은 복사 vs 깊은 복사
import copy

nested = [[1, 2], [3, 4]]

shallow = nested[:]          # 얕은 복사: 내부 리스트는 공유
deep = copy.deepcopy(nested) # 깊은 복사: 내부까지 재귀 복사

nested[0][0] = 99
print(shallow)  # [[99, 2], [3, 4]]  (영향 받음)
print(deep)     # [[1, 2], [3, 4]]   (영향 없음)
```
## `*` 연산자 주의(반복에 의한 참조 공유)
```pyhon
# 흔한 함정: 내부 리스트가 모두 같은 객체를 가리킴
grid_bad = [[0]*3]*2
grid_bad[0][0] = 1
print(grid_bad)     # [[1, 0, 0], [1, 0, 0]]

# 올바른 방법: 컴프리헨션으로 독립 리스트 생성
grid_ok = [[0]*3 for _ in range(2)]
grid_ok[0][0] = 1
print(grid_ok)      # [[1, 0, 0], [0, 0, 0]]
```

# 오늘의 요약

- 인덱스는 O(1), 슬라이스는 잘라내는 길이에 비례해 O(k) 비용.

- 리스트는 뮤터블, 튜플은 이뮤터블 — 대입은 참조 연결이므로 복사 아님.

- 슬라이스 읽기는 새 객체 생성, 쓰기는 구간 치환(리스트만).

- 중첩 구조에선 얕은/깊은 복사 차이를 꼭 이해하기.

- `[*]*n` 패턴은 내부 리스트 공유 함정 주의 → 컴프리헨션 사용!
