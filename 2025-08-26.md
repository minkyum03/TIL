# TIL — World Toggle Lite (Unity 2D 프로토)

Date: 2025-08-26
Engine: Unity 2022.3 LTS (2D Core)
Goal: 키 E로 월드 A/B를 교대해 길을 바꾸는 2D 플랫포머 프로토타입

# 오늘 한 일

Grid/Tilemap 기반 WorldA / WorldB 구성

Tile Palette로 타일 그리기 & 충돌 구성(TilemapCollider2D)

Player 이동/점프(groundCheck 기반 접지 감지)

리스폰(낙사/함정), KillZone(Trigger)

월드 토글(A/B 렌더러·콜라이더 교대, 디버그 키 포함)

Cinemachine 2D로 카메라 팔로우

단순 사각형 함정(Trigger) 생성

프로젝트/씬 구조
```scss
Grid
 ├─ WorldA (Tilemap, TilemapCollider2D [Layer=Ground], [CompositeCollider2D], Rigidbody2D(Static))
 └─ WorldB (Tilemap, TilemapCollider2D [Layer=Ground], [CompositeCollider2D], Rigidbody2D(Static))
Player (Rigidbody2D Dynamic, Collider2D, PlayerController2D, Respawn, Tag=Player)
Game (WorldToggle)   // worldA=WorldA, worldB=WorldB
SpawnPoint (시작 지점)
KillZone (BoxCollider2D IsTrigger + KillZone)
Virtual Camera (Cinemachine 2D, Follow=Player)
```
핵심 구현

## 1) 이동/점프 — `PlayerController2D.cs`
```csharp
using UnityEngine;

public class PlayerController2D : MonoBehaviour
{
    [Header("Move/Jump")]
    public float moveSpeed = 6f;
    public float jumpForce = 13f;
    public Transform groundCheck;     // Player 자식, 발밑 바로 아래
    public float groundRadius = 0.15f; 
    public LayerMask groundLayer;     // Ground만 체크

    Rigidbody2D rb;
    bool isGrounded;
    float move;

    void Awake() => rb = GetComponent<Rigidbody2D>();

    void Update()
    {
        move = Input.GetAxisRaw("Horizontal");
        if (Input.GetButtonDown("Jump") && isGrounded)
            rb.velocity = new Vector2(rb.velocity.x, jumpForce);
    }

    void FixedUpdate()
    {
        rb.velocity = new Vector2(move * moveSpeed, rb.velocity.y);
        isGrounded = Physics2D.OverlapCircle(groundCheck.position, groundRadius, groundLayer);
    }

    // 디버그용: 접지 반경 시각화
    void OnDrawGizmosSelected()
    {
        if (!groundCheck) return;
        Gizmos.color = Color.green;
        Gizmos.DrawWireSphere(groundCheck.position, groundRadius);
    }
}
```

중요 파라미터

`Rigidbody2D`: Dynamic, Freeze Z Rotation, Gravity Scale 2.5~3.5

`groundCheck`: 로컬 (0, -0.5, 0) 근처(콜라이더 바닥보다 살짝 아래)

`groundLayer`: Ground만 포함(Everything/Nothing 금지)

이론 메모

`OverlapCircle`로 원형 접지 → 경사/타일 경계에서 안정적

이동/물리는 `FixedUpdate`에서 처리(물리 프레임)

## 2) 리스폰/낙사 — `Respawn.cs`, `KillZone.cs`
```csharp
// Player에 부착
public class Respawn : MonoBehaviour
{
    public Transform currentSpawn; // 시작 시 SpawnPoint 연결
    Rigidbody2D rb;
    void Awake() => rb = GetComponent<Rigidbody2D>();
    public void DoRespawn() { rb.velocity = Vector2.zero; transform.position = currentSpawn.position; }
}

// 함정/낙사존에 부착 (Collider2D IsTrigger 필요)
public class KillZone : MonoBehaviour
{
    void OnTriggerEnter2D(Collider2D other)
    {
        var r = other.GetComponent<Respawn>();
        if (r != null) r.DoRespawn();
    }
}
```
## 3) 세계 토글 — `WorldToggle.cs` (안전 버전)
```csharp
using UnityEngine;
using UnityEngine.Tilemaps;

public class WorldToggle : MonoBehaviour
{
    [SerializeField] private GameObject worldA;   // Hierarchy의 WorldA
    [SerializeField] private GameObject worldB;   // Hierarchy의 WorldB
    [SerializeField] private bool startWithA = true;

    private TilemapRenderer rA, rB;
    private Tilemap tA, tB;
    private Collider2D[] collA, collB;
    private bool isAOn;

    void Awake()
    {
        rA = worldA.GetComponent<TilemapRenderer>();
        rB = worldB.GetComponent<TilemapRenderer>();
        tA = worldA.GetComponent<Tilemap>();
        tB = worldB.GetComponent<Tilemap>();
        collA = worldA.GetComponents<Collider2D>();
        collB = worldB.GetComponents<Collider2D>();

        isAOn = startWithA;
        Apply();
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.E)) { isAOn = !isAOn; Apply(); }
        if (Input.GetKeyDown(KeyCode.Q)) SetState(true, true);   // 디버그: 둘 다 ON
        if (Input.GetKeyDown(KeyCode.R)) { isAOn = true; Apply(); } // A만 ON
    }

    void Apply() => SetState(isAOn, !isAOn);

    void SetState(bool aOn, bool bOn)
    {
        if (rA) rA.enabled = aOn;      if (rB) rB.enabled = bOn;
        if (tA) tA.color = aOn ? Color.white : new Color(1,1,1,0.25f);
        if (tB) tB.color = bOn ? Color.white : new Color(1,1,1,0.25f);
        if (collA != null) foreach (var c in collA) if (c) c.enabled = aOn;
        if (collB != null) foreach (var c in collB) if (c) c.enabled = bOn;
    }
}
```
왜 SetActive 대신 컴포넌트 토글?
- 부모(Grid) 잘못 참조/비활성 시 스크립트 자체가 꺼지는 상황 방지. 렌더러·콜라이더만 교대하면 안전.

## 4) 카메라 — Cinemachine 2D

- `Package Manage`r에서 설치 → `GameObject ▸ Cinemachine ▸ 2D Camera`
- Virtual Camera의 Follow = Player
- Body: Framing Transposer(기본값 OK)

## 5) 타일 팔레트 사용(핵심 절차)

 1. `Window ▸ 2D ▸ Tile Palette` 열기 → Create New Palette
 2. `Sprites/Square`를 팔레트로 드래그 → `Assets/Tiles`에 Tile asset 생성
 3. Active Tilemap을 `WorldA` 또는 `WorldB`로 선택
 4. Scene에서 브러시/사각형 채우기로 그리기(우클릭 지우기)
 5. `TilemapCollider2D` 붙이고 Layer=Ground, 필요 시 `CompositeCollider2D + Used by Composite`


## 장애물(간단 사각형)

- `GameObject ▸ 2D Object ▸ Sprite ▸ Square` → 빨간색
- `BoxCollider2D (Is Trigger)` + `KillZone.cs`
- 마우스 Rect 툴(T) 로 위치/크기 조절, Ctrl(Win)/Cmd(Mac) 스냅 사용

## 오늘 겪은 문제와 해결

- 점프가 안 됨 / `grounded? false`
  - `groundCheck` 위치가 발밑이 아님 → 로컬 (0,-0.5,0) 근처로 조정
  - `groundLayer`에 Ground만 체크
  - `WorldA/B`에 `TilemapCollider2D` 누락 확인

- E 누르면 둘 다 사라짐 / 다시 안 켜짐
  - `WorldToggle`에 `Grid`를 참조한 실수 → `WorldA/WorldB` 오브젝트로 재지정
  - SetActive 대신 Renderer/Collider 교대 버전으로 변경(상기 코드)

- B가 안 보임
  - 해당 위치 WorldB 타일 없음 → `Q`로 둘 다 ON 후 Scene에서 존재 확인, 팔레트로 채우기

- A/B y축이 어긋나 보임
  - `Grid`,` WorldA`, `WorldB` Transform Reset(0,0,0 / 1,1,1)
  - `Tilemap ▸ Tile Anchor = (0,0,0)`

- TilemapRenderer.color 에러
  - 색상은 `Tilemap.color` 로 제어해야 함(컴포넌트 구분)

## 성능/품질 메모

타일 경계에서 걸리면 `CompositeCollider2D` + `Used by Composite`로 합치기

이동 발판 위 미끄러짐은 `Player Rigidbody2D ▸ Interpolate` 사용으로 완화

## 내일 할 일

튜토리얼 완성하기

이동 발판 구현/배치

Checkpoint 추가 배치, UI에 `E: 세계 토글` 힌트 표시

SFX(점프/사망/토글) 임시 연결
